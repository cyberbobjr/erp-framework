<?php

    namespace OperationsManager\Model\Table;

    use App\Model\Behavior\SearchBehavior;
    use Cake\Event\Event;
    use Cake\Event\EventManager;
    use Cake\I18n\Date;
    use Cake\ORM\Association\BelongsTo;
    use Cake\ORM\Association\belongsToMany;
    use Cake\ORM\Association\HasMany;
    use Cake\ORM\Behavior\TimestampBehavior;
    use Cake\ORM\Query;
    use Cake\ORM\RulesChecker;
    use Cake\ORM\Table;
    use Cake\ORM\TableRegistry;
    use Cake\Validation\Validator;
    use CompaniesManager\Model\Table\CompaniesTable;
    use OperationsManager\Model\Entity\Operation;
    use OperationsManager\State\DraftState;
    use OperationsManager\State\OpsStateEnum;
    use PaymentsManager\Model\Table\OperationsPaymentsTable;
    use TiersManager\Model\Table\CustomersTable;

    /**
     * Class OperationsTable
     * @property CompaniesTable|BelongsTo $Companies
     * @property BelongsTo $Bails
     * @property BelongsTo $TypeEtats
     * @property TypeOpsTable|BelongsTo $TypeOps
     * @property Table|BelongsTo $TypeOperations
     * @property BelongsTo $OperationsReglements
     * @property OperationdetailsTable|HasMany $Operationdetails
     * @property belongsToMany Reglements
     * @property CustomersTable|BelongsTo $Customers
     * @package App\Model\Table
     * @property TypeStatesTable|BelongsTo $TypeOpsStates
     * @property Table|BelongsTo $Leases
     * @property OperationsPaymentsTable|HasMany $OperationsPayments
     * @property Table|BelongsToMany $Payments
     * @method Operation get($primaryKey, $options = [])
     * @method Operation newEntity($data = NULL, array $options = [])
     * @method Operation[] newEntities(array $data, array $options = [])
     * @method Operation|bool save(\Cake\Datasource\EntityInterface $entity, $options = [])
     * @method Operation saveOrFail(\Cake\Datasource\EntityInterface $entity, $options = [])
     * @method Operation patchEntity(\Cake\Datasource\EntityInterface $entity, array $data, array $options = [])
     * @method Operation[] patchEntities($entities, array $data, array $options = [])
     * @method Operation findOrCreate($search, callable $callback = NULL, $options = [])
     * @mixin TimestampBehavior
     * @mixin SearchBehavior
     */
    class OperationsTable extends Table
    {
        public function initialize(array $config)
        {
            $this->addBehavior('Timestamp');
            $this->addBehavior('Search');

            $this->belongsTo('OperationsManager.TypeOps')
                 ->setForeignKey('type_op_id');

            $this->hasMany('OperationsManager.Operationdetails')
                 ->setDependent(TRUE)
                 ->setSaveStrategy('replace');

            $this->belongsToMany('PaymentsManager.Payments')
                 ->setThrough('OperationsPayments');

            $this->belongsTo('TiersManager.Customers')
                 ->setForeignKey('tier_id');

            $this->belongsTo('CompaniesManager.Companies')
                 ->setForeignKey('company_id');

            $this->setDisplayField('label');
        }

        public function validationDefault(Validator $validator)
        {
            $validator->requirePresence('label');
            return $validator;
        }

        public function buildRules(RulesChecker $rules)
        {
            return parent::buildRules($rules); // TODO: Change the autogenerated stub
        }


        /**
         * Fonction executée avant la sauvegarde d'une opération
         * @param  Event  $event  Evenement générateur
         * @param  Operation  $entity  Entité sauvegardée
         * @param           $options
         * @return bool TRUE pour autoriser la sauvegarde, FALSE pour refuser
         */
        public function beforeSave(Event $event, Operation $entity, $options)
        {
            $this->_calculateSumOperation($entity);
            return TRUE;
        }

        public function afterSave(Event $event, Operation $entity)
        {
            $eventName = $entity->isNew() ? 'Model.Operations.created' : 'Model.Operations.modified';
            EventManager::instance()
                        ->dispatch(new Event($eventName, $this, ['operation' => $entity]));
        }

        public function saveFullOps($operation_id, $data): Operation
        {
            $operation = $this->get($operation_id);
            $operation = $this->patchEntity($operation, $data);

            $result = $this->save($operation);
            return $operation;
        }

        private function _calculateSumOperation(Operation &$entity)
        {
            if ($entity->has('operationdetails')) {
                $total_without_vat = 0;
                $total_vat = 0;
                $total_included_vat = 0;
                foreach ($entity->operationdetails as $detail) {
                    $total_without_vat += $detail->total_without_vat;
                    $total_vat += $detail->total_vat;
                    $total_included_vat += $detail->total_included_vat;
                }
                $entity = $this->patchEntity($entity, ['total_without_vat'  => $total_without_vat,
                                                       'total_vat'          => $total_vat,
                                                       'total_included_vat' => $total_included_vat]);
            }
        }

        private function _calculateBalance(Operation $entity): Operation
        {
            if ($entity->has('id') && $entity->has('total_included_vat')) {
                $operationsTable = TableRegistry::getTableLocator()
                                                ->get('OperationsPayments');
                $reglements = $operationsTable->find()
                                              ->contain(['Payments',
                                                         'Operations'])
                                              ->where(['operation_id' => $entity->id]);
                $reglements = $reglements->select(['total_amount' => $reglements->func()
                                                                                ->sum('amount')])
                                         ->first();
                $entity = $this->patchEntity($entity, ['balance' => ($entity->total_included_vat - $reglements->total_amount)]);
            }
            return $entity;
        }

        public function updateBalance($operation_id)
        {
            $operation = $this->get($operation_id);
            $operation = $this->_calculateBalance($operation);
            return $this->save($operation);
        }

        public function isTypeExist($id)
        {
            return FALSE;
        }

        public function getLastOperations($long = 5)
        {
            $start = date('Y-m-d', strtotime('-'.abs($long).' month'));
            $end = (new Date())->modify('last day of this month')
                               ->format('Y-m-d');
            $montant = $this->find('all')
                            ->select(['somme' => 'SUM(balance)',
                                      'due_date',
                                      'mois'  => 'MONTH(due_date)'])
                            ->where(function ($q) use ($start, $end) {
                                return $q->between('due_date', $start, $end);
                            })
                            ->group(['MONTH(due_date)']);
            return $montant;
        }

        public function getAllOperations($filter = NULL)
        {
            return $this->find('all')
                        ->order(['Operations.date_echeance' => 'DESC'])
                        ->contain(['TypeOpsStates',
                                   'Companies',
                                   'Operationdetails',
                                   'Operationdetails.Tvas',
                                   'Operationdetails.TypeOperations',
                                   'Leases',
                                   'Leases.Properties',
                                   'Customers']);
        }

        public function getOperationById($operation_id)
        {
            return $this->get($operation_id, ['contain' => ['Operationdetails',
                                                            'TypeOpsStates',
                                                            'Customers',
                                                            'Leases']]);
        }

        /**
         * Indique qu'une opération est payée
         * @param  int  $operation_id  Référence de l'opération
         * @return bool|\Cake\Datasource\EntityInterface|mixed
         */
        public function setPaid($operation_id)
        {
            return $this->setState($operation_id, OpsStateEnum::$STATE_CLOSED);
        }

        /**
         * Change l'état d'une opération
         * @param  int  $operation_id  Référence de l'opération concernée par le changement d'état
         * @param  int  $state  Etat à positionner
         * @return bool|\Cake\Datasource\EntityInterface|mixed
         */
        private function setState($operation_id, $state)
        {
            $entity = $this->get($operation_id);
            $this->patchEntity($entity, ['state' => $state]);
            return $this->save($entity);
        }

        /**
         * Indique qu'une opération est impayée
         * @param  int  $operation_id  Référence de l'opération
         * @return bool|\Cake\Datasource\EntityInterface|mixed
         */
        public function setUnpaid($operation_id)
        {
            return $this->setState($operation_id, OpsStateEnum::$STATE_OPEN);
        }

        /**
         * Indique qu'une opération est en état brouillon
         * @param  int  $operation_id  Référence de l'opération
         * @return bool|\Cake\Datasource\EntityInterface|mixed
         */
        public function reOpen($operation_id)
        {
            $operation = $this->get($operation_id);
            $new_state = ($operation->balance > 0) ? OpsStateEnum::$STATE_OPEN : OpsStateEnum::$STATE_DRAFT;
            return $this->setState($operation_id, $new_state);
        }

        public function setDraft($operation_id)
        {
            return $this->setState($operation_id, OpsStateEnum::$STATE_DRAFT);
        }

        public function setOpen($operation_id)
        {
            return $this->setState($operation_id, OpsStateEnum::$STATE_OPEN);
        }

        /**
         * Indique qu'une opération est abandonnée
         * @param  int  $operation_id  Référence de l'opération à abandonner
         * @return bool|\Cake\Datasource\EntityInterface|mixed
         */
        public function setCancel($operation_id)
        {
            return $this->setState($operation_id, OpsStateEnum::STATE_CANCELLED);
        }

        /**
         * Indique qu'une opération est partiellement payée
         * @param  int  $operation_id  Référence de l'opération à abandonner
         * @return bool|\Cake\Datasource\EntityInterface|mixed
         */
        public function setPartial($operation_id)
        {
            return $this->setState($operation_id, OpsStateEnum::STATE_OPEN);
        }

        public function getUnpaids($tier_id)
        {
            return $this->find('all')
                        ->where(['tier_id'    => $tier_id,
                                 'balance >=' => 0,
                                 'state'      => OpsStateEnum::$STATE_OPEN])
                        ->contain(['TypeStates',
                                   'Payments',
                                   'Customers']);
        }

        public function findUnpaid(Query $query, array $options)
        {
            return $query->where(['balance >' => 0,
                                  'state'     => OpsStateEnum::$STATE_OPEN]);
        }

        public function getCustomersList()
        {
            return $this->Customers->find('list')
                                   ->order('lastname')
                                   ->toList();
        }

        public function getCompaniesList()
        {
            return $this->Companies->find('list')
                                   ->toList();
        }

        public function getTypeOpsList()
        {
            return $this->TypeOps->find('list')
                                 ->orderAsc('label')
                                 ->toList();
        }

        public function createNewOp(array $newOpData): Operation
        {
            $entity = $this->newEntity($newOpData);
            $entity = DraftState::setNewState($entity);
            $this->save($entity);
            return $entity;
        }
    }
